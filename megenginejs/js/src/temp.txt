    auto t1 = makeTND({5});
    auto t2 = makeTND({5});
    auto handle1 = interpreter_for_js->put(*t1, true);
    auto handle2 = interpreter_for_js->put(*t2, true);
    SmallVector<mgb::imperative::interpreter::Interpreter::Handle> handleVec(2);
    handleVec[0] = handle1;
    handleVec[1] = handle2;
    auto op = std::shared_ptr<OpDef>(Elemwise::make(Elemwise::Mode::ADD));

    auto output_handles = interpreter_for_js->apply_op(op, handleVec);
    std::cout << "build outputs " << std::endl;
    apply_result_t outputs;
    outputs.reserve(output_handles.size());
    for (auto h : output_handles) {
        outputs.emplace_back(std::make_shared<Tensor>(h));
    }
    std::cout << "return outputs " << std::endl;

    auto applyOut = outputs[0];
    auto applyData = applyOut->value().ptr<float>();
    for(int i = 0; i < 5; i++){
        std::cout << applyData[i] << std::endl;
    }